/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CompleteForgotPasswordArgs
 */
export interface CompleteForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'confirmPassword': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CompleteSignUpArgs
 */
export interface CompleteSignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreateEngineProjectDto
 */
export interface CreateEngineProjectDto {
    /**
     * 
     * @type {string}
     * @memberof CreateEngineProjectDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CreateEngineProjectDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEngineProjectDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEngineProjectDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateEngineProjectDto
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWebhookDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof CreateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface EngineControllerSignIn400Response
 */
export interface EngineControllerSignIn400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof EngineControllerSignIn400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof EngineControllerSignIn400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof EngineControllerSignIn400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface EngineEmailTemplate
 */
export interface EngineEmailTemplate {
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplate
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplate
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplate
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplate
     */
    'updatedAt': string;
    /**
     * 
     * @type {EngineProject}
     * @memberof EngineEmailTemplate
     */
    'EngineProject'?: EngineProject;
}
/**
 * 
 * @export
 * @interface EngineEmailTemplateDto
 */
export interface EngineEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplateDto
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplateDto
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof EngineEmailTemplateDto
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineEmailTemplateDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineEmailTemplateScalarFieldEnum = {
    Id: 'id',
    Subject: 'subject',
    SubjectLocale: 'subjectLocale',
    Text: 'text',
    TextLocale: 'textLocale',
    Html: 'html',
    HtmlLocale: 'htmlLocale',
    OperationName: 'operationName',
    ProjectId: 'projectId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineEmailTemplateScalarFieldEnum = typeof EngineEmailTemplateScalarFieldEnum[keyof typeof EngineEmailTemplateScalarFieldEnum];


/**
 * 
 * @export
 * @interface EngineEntities
 */
export interface EngineEntities {
    /**
     * 
     * @type {EngineProjectScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineProject': EngineProjectScalarFieldEnum;
    /**
     * 
     * @type {EngineUserScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineUser': EngineUserScalarFieldEnum;
    /**
     * 
     * @type {EngineRefreshSessionScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineRefreshSession': EngineRefreshSessionScalarFieldEnum;
    /**
     * 
     * @type {EngineEmailTemplateScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineEmailTemplate': EngineEmailTemplateScalarFieldEnum;
    /**
     * 
     * @type {EngineOAuthProviderScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineOAuthProvider': EngineOAuthProviderScalarFieldEnum;
    /**
     * 
     * @type {EngineOAuthProviderSettingsScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineOAuthProviderSettings': EngineOAuthProviderSettingsScalarFieldEnum;
    /**
     * 
     * @type {EngineOAuthTokenScalarFieldEnum}
     * @memberof EngineEntities
     */
    'EngineOAuthToken': EngineOAuthTokenScalarFieldEnum;
    /**
     * 
     * @type {EngineRole}
     * @memberof EngineEntities
     */
    'role': EngineRole;
}


/**
 * 
 * @export
 * @interface EngineError
 */
export interface EngineError {
    /**
     * Engine error (ENGINE-000), User not found (ENGINE-001), Wrong password (ENGINE-002), User is exists (ENGINE-003), Wrong activate email code (ENGINE-004), Activate email not processed (ENGINE-005), Activate email processed (ENGINE-006), Refresh token not provided (ENGINE-007), Session expired (ENGINE-008), Invalid refresh session (ENGINE-009), Access token expired (ENGINE-010), User is exists (ENGINE-011), Email not verified (ENGINE-012), Forbidden (ENGINE-013), Wrong old password (ENGINE-014), Non-existent role specified (ENGINE-015), Bad access token (ENGINE-016), Your session has been blocked (ENGINE-017), Verification code not found (ENGINE-018)
     * @type {string}
     * @memberof EngineError
     */
    'message': string;
    /**
     * 
     * @type {EngineErrorEnum}
     * @memberof EngineError
     */
    'code': EngineErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof EngineError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EngineErrorEnum = {
    Engine000: 'ENGINE-000',
    Engine001: 'ENGINE-001',
    Engine002: 'ENGINE-002',
    Engine003: 'ENGINE-003',
    Engine004: 'ENGINE-004',
    Engine005: 'ENGINE-005',
    Engine006: 'ENGINE-006',
    Engine007: 'ENGINE-007',
    Engine008: 'ENGINE-008',
    Engine009: 'ENGINE-009',
    Engine010: 'ENGINE-010',
    Engine011: 'ENGINE-011',
    Engine012: 'ENGINE-012',
    Engine013: 'ENGINE-013',
    Engine014: 'ENGINE-014',
    Engine015: 'ENGINE-015',
    Engine016: 'ENGINE-016',
    Engine017: 'ENGINE-017',
    Engine018: 'ENGINE-018'
} as const;

export type EngineErrorEnum = typeof EngineErrorEnum[keyof typeof EngineErrorEnum];


/**
 * 
 * @export
 * @interface EngineOAuthProvider
 */
export interface EngineOAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<EngineOAuthProviderSettings>}
     * @memberof EngineOAuthProvider
     */
    'EngineOAuthProviderSettings'?: Array<EngineOAuthProviderSettings>;
    /**
     * 
     * @type {Array<EngineOAuthToken>}
     * @memberof EngineOAuthProvider
     */
    'EngineOAuthToken'?: Array<EngineOAuthToken>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineOAuthProviderScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineOAuthProviderScalarFieldEnum = typeof EngineOAuthProviderScalarFieldEnum[keyof typeof EngineOAuthProviderScalarFieldEnum];


/**
 * 
 * @export
 * @interface EngineOAuthProviderSettings
 */
export interface EngineOAuthProviderSettings {
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthProviderSettings
     */
    'updatedAt': string;
    /**
     * 
     * @type {EngineOAuthProvider}
     * @memberof EngineOAuthProviderSettings
     */
    'EngineOAuthProvider'?: EngineOAuthProvider;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineOAuthProviderSettingsScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Value: 'value',
    ProviderId: 'providerId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineOAuthProviderSettingsScalarFieldEnum = typeof EngineOAuthProviderSettingsScalarFieldEnum[keyof typeof EngineOAuthProviderSettingsScalarFieldEnum];


/**
 * 
 * @export
 * @interface EngineOAuthToken
 */
export interface EngineOAuthToken {
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'grantedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'tokenType': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'scope': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'verificationCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'providerUserId': string;
    /**
     * 
     * @type {object}
     * @memberof EngineOAuthToken
     */
    'providerUserData': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthToken
     */
    'updatedAt': string;
    /**
     * 
     * @type {EngineProject}
     * @memberof EngineOAuthToken
     */
    'EngineOAuthProvider_EngineOAuthToken_projectIdToEngineOAuthProvider'?: EngineProject;
    /**
     * 
     * @type {EngineOAuthProvider}
     * @memberof EngineOAuthToken
     */
    'EngineOAuthProvider'?: EngineOAuthProvider;
    /**
     * 
     * @type {EngineUser}
     * @memberof EngineOAuthToken
     */
    'EngineUser'?: EngineUser;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineOAuthTokenScalarFieldEnum = {
    Id: 'id',
    GrantedAt: 'grantedAt',
    AccessToken: 'accessToken',
    RefreshToken: 'refreshToken',
    ExpiresAt: 'expiresAt',
    TokenType: 'tokenType',
    Scope: 'scope',
    VerificationCode: 'verificationCode',
    UserId: 'userId',
    ProjectId: 'projectId',
    ProviderId: 'providerId',
    ProviderUserId: 'providerUserId',
    ProviderUserData: 'providerUserData',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineOAuthTokenScalarFieldEnum = typeof EngineOAuthTokenScalarFieldEnum[keyof typeof EngineOAuthTokenScalarFieldEnum];


/**
 * 
 * @export
 * @interface EngineOAuthVerificationArgs
 */
export interface EngineOAuthVerificationArgs {
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthVerificationArgs
     */
    'verificationCode': string;
    /**
     * 
     * @type {string}
     * @memberof EngineOAuthVerificationArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface EngineProject
 */
export interface EngineProject {
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof EngineProject
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof EngineProject
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProject
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<EngineEmailTemplate>}
     * @memberof EngineProject
     */
    'EngineEmailTemplate'?: Array<EngineEmailTemplate>;
    /**
     * 
     * @type {Array<EngineOAuthToken>}
     * @memberof EngineProject
     */
    'EngineOAuthToken_EngineOAuthToken_projectIdToEngineOAuthProvider'?: Array<EngineOAuthToken>;
    /**
     * 
     * @type {Array<EngineRefreshSession>}
     * @memberof EngineProject
     */
    'EngineRefreshSession'?: Array<EngineRefreshSession>;
    /**
     * 
     * @type {Array<EngineUser>}
     * @memberof EngineProject
     */
    'EngineUser'?: Array<EngineUser>;
}
/**
 * 
 * @export
 * @interface EngineProjectDto
 */
export interface EngineProjectDto {
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof EngineProjectDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof EngineProjectDto
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineProjectDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineProjectScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    NameLocale: 'nameLocale',
    ClientId: 'clientId',
    ClientSecret: 'clientSecret',
    Public: 'public',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineProjectScalarFieldEnum = typeof EngineProjectScalarFieldEnum[keyof typeof EngineProjectScalarFieldEnum];


/**
 * 
 * @export
 * @interface EnginePublicProjectDto
 */
export interface EnginePublicProjectDto {
    /**
     * 
     * @type {string}
     * @memberof EnginePublicProjectDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnginePublicProjectDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof EnginePublicProjectDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof EnginePublicProjectDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof EnginePublicProjectDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnginePublicProjectDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface EngineRefreshSession
 */
export interface EngineRefreshSession {
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof EngineRefreshSession
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof EngineRefreshSession
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSession
     */
    'updatedAt': string;
    /**
     * 
     * @type {EngineProject}
     * @memberof EngineRefreshSession
     */
    'EngineProject'?: EngineProject;
    /**
     * 
     * @type {EngineUser}
     * @memberof EngineRefreshSession
     */
    'EngineUser'?: EngineUser;
}
/**
 * 
 * @export
 * @interface EngineRefreshSessionDto
 */
export interface EngineRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof EngineRefreshSessionDto
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof EngineRefreshSessionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineRefreshSessionDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineRefreshSessionScalarFieldEnum = {
    Id: 'id',
    RefreshToken: 'refreshToken',
    UserAgent: 'userAgent',
    Fingerprint: 'fingerprint',
    UserIp: 'userIp',
    ExpiresAt: 'expiresAt',
    UserData: 'userData',
    Enabled: 'enabled',
    UserId: 'userId',
    ProjectId: 'projectId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineRefreshSessionScalarFieldEnum = typeof EngineRefreshSessionScalarFieldEnum[keyof typeof EngineRefreshSessionScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const EngineRole = {
    Admin: 'admin',
    Manager: 'manager',
    User: 'user'
} as const;

export type EngineRole = typeof EngineRole[keyof typeof EngineRole];


/**
 * 
 * @export
 * @interface EngineUser
 */
export interface EngineUser {
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof EngineUser
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof EngineUser
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<EngineOAuthToken>}
     * @memberof EngineUser
     */
    'EngineOAuthToken'?: Array<EngineOAuthToken>;
    /**
     * 
     * @type {Array<EngineRefreshSession>}
     * @memberof EngineUser
     */
    'EngineRefreshSession'?: Array<EngineRefreshSession>;
    /**
     * 
     * @type {EngineProject}
     * @memberof EngineUser
     */
    'EngineProject'?: EngineProject;
}
/**
 * 
 * @export
 * @interface EngineUserDto
 */
export interface EngineUserDto {
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof EngineUserDto
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof EngineUserDto
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EngineUserDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EngineUserScalarFieldEnum = {
    Id: 'id',
    Email: 'email',
    Phone: 'phone',
    Username: 'username',
    Password: 'password',
    Roles: 'roles',
    Firstname: 'firstname',
    Lastname: 'lastname',
    Gender: 'gender',
    Birthdate: 'birthdate',
    Picture: 'picture',
    AppData: 'appData',
    RevokedAt: 'revokedAt',
    EmailVerifiedAt: 'emailVerifiedAt',
    PhoneVerifiedAt: 'phoneVerifiedAt',
    Timezone: 'timezone',
    Lang: 'lang',
    ProjectId: 'projectId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type EngineUserScalarFieldEnum = typeof EngineUserScalarFieldEnum[keyof typeof EngineUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface FilesError
 */
export interface FilesError {
    /**
     * Files error (FILES-000), Forbidden (FILES-001)
     * @type {string}
     * @memberof FilesError
     */
    'message': string;
    /**
     * 
     * @type {FilesErrorEnum}
     * @memberof FilesError
     */
    'code': FilesErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof FilesError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FilesErrorEnum = {
    Files000: 'FILES-000',
    Files001: 'FILES-001'
} as const;

export type FilesErrorEnum = typeof FilesErrorEnum[keyof typeof FilesErrorEnum];


/**
 * 
 * @export
 * @interface FilesPresignedUrls
 */
export interface FilesPresignedUrls {
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'downloadUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface FindManyEngineEmailTemplateResponse
 */
export interface FindManyEngineEmailTemplateResponse {
    /**
     * 
     * @type {Array<EngineEmailTemplateDto>}
     * @memberof FindManyEngineEmailTemplateResponse
     */
    'engineEmailTemplates': Array<EngineEmailTemplateDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyEngineEmailTemplateResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyEngineProjectResponse
 */
export interface FindManyEngineProjectResponse {
    /**
     * 
     * @type {Array<EngineProjectDto>}
     * @memberof FindManyEngineProjectResponse
     */
    'engineProjects': Array<EngineProjectDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyEngineProjectResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyEnginePublicProjectResponse
 */
export interface FindManyEnginePublicProjectResponse {
    /**
     * 
     * @type {Array<EnginePublicProjectDto>}
     * @memberof FindManyEnginePublicProjectResponse
     */
    'enginePublicProjects': Array<EnginePublicProjectDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyEnginePublicProjectResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyEngineRefreshSessionResponse
 */
export interface FindManyEngineRefreshSessionResponse {
    /**
     * 
     * @type {Array<EngineRefreshSessionDto>}
     * @memberof FindManyEngineRefreshSessionResponse
     */
    'engineRefreshSessions': Array<EngineRefreshSessionDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyEngineRefreshSessionResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyEngineRoleResponse
 */
export interface FindManyEngineRoleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManyEngineRoleResponse
     */
    'userAvailableRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManyEngineRoleResponse
     */
    'userDefaultRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManyEngineRoleResponse
     */
    'adminDefaultRoles': Array<string>;
}
/**
 * 
 * @export
 * @interface FindManyEngineUserResponse
 */
export interface FindManyEngineUserResponse {
    /**
     * 
     * @type {Array<EngineUserDto>}
     * @memberof FindManyEngineUserResponse
     */
    'engineUsers': Array<EngineUserDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyEngineUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyNotificationResponse
 */
export interface FindManyNotificationResponse {
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof FindManyNotificationResponse
     */
    'notifications': Array<NotificationsEvent>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyNotificationResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyResponseMeta
 */
export interface FindManyResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'curPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'totalResults': number;
}
/**
 * 
 * @export
 * @interface FindManyWebhookLogResponse
 */
export interface FindManyWebhookLogResponse {
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof FindManyWebhookLogResponse
     */
    'webhookLogs': Array<WebhookLog>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookLogResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookResponse
 */
export interface FindManyWebhookResponse {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof FindManyWebhookResponse
     */
    'webhooks': Array<Webhook>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface ForgotPasswordArgs
 */
export interface ForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface NotificationsControllerFindMany400Response
 */
export interface NotificationsControllerFindMany400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof NotificationsControllerFindMany400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof NotificationsControllerFindMany400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof NotificationsControllerFindMany400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface NotificationsEntities
 */
export interface NotificationsEntities {
    /**
     * 
     * @type {NotificationsUserScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsUser': NotificationsUserScalarFieldEnum;
    /**
     * 
     * @type {NotificationsEventScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsEvent': NotificationsEventScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface NotificationsError
 */
export interface NotificationsError {
    /**
     * Notifications error (NOTIFICATIONS-000), Tenant ID not set (NOTIFICATIONS-001), User ID not set (NOTIFICATIONS-002), Forbidden (NOTIFICATIONS-003)
     * @type {string}
     * @memberof NotificationsError
     */
    'message': string;
    /**
     * 
     * @type {NotificationsErrorEnum}
     * @memberof NotificationsError
     */
    'code': NotificationsErrorEnum;
    /**
     * 
     * @type {Array<NotificationsErrorMetadata>}
     * @memberof NotificationsError
     */
    'metadata'?: Array<NotificationsErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsErrorEnum = {
    Notifications000: 'NOTIFICATIONS-000',
    Notifications001: 'NOTIFICATIONS-001',
    Notifications002: 'NOTIFICATIONS-002',
    Notifications003: 'NOTIFICATIONS-003'
} as const;

export type NotificationsErrorEnum = typeof NotificationsErrorEnum[keyof typeof NotificationsErrorEnum];


/**
 * 
 * @export
 * @interface NotificationsErrorMetadata
 */
export interface NotificationsErrorMetadata {
    /**
     * 
     * @type {string}
     * @memberof NotificationsErrorMetadata
     */
    'property': string;
    /**
     * 
     * @type {Array<NotificationsErrorMetadataConstraint>}
     * @memberof NotificationsErrorMetadata
     */
    'constraints': Array<NotificationsErrorMetadataConstraint>;
    /**
     * 
     * @type {Array<NotificationsErrorMetadata>}
     * @memberof NotificationsErrorMetadata
     */
    'children'?: Array<NotificationsErrorMetadata>;
}
/**
 * 
 * @export
 * @interface NotificationsErrorMetadataConstraint
 */
export interface NotificationsErrorMetadataConstraint {
    /**
     * 
     * @type {string}
     * @memberof NotificationsErrorMetadataConstraint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsErrorMetadataConstraint
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface NotificationsEvent
 */
export interface NotificationsEvent {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEvent
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEvent
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'error': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'senderUserId': string | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientUserId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_recipientUserIdToNotificationsUser'?: NotificationsUser;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_senderUserIdToNotificationsUser'?: NotificationsUser | null;
}
/**
 * 
 * @export
 * @interface NotificationsEventDto
 */
export interface NotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEventDto
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEventDto
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'error': object | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsEventScalarFieldEnum = {
    Id: 'id',
    Type: 'type',
    OperationName: 'operationName',
    Subject: 'subject',
    Html: 'html',
    Text: 'text',
    Attempt: 'attempt',
    Used: 'used',
    Error: 'error',
    SenderUserId: 'senderUserId',
    SenderData: 'senderData',
    RecipientGroupId: 'recipientGroupId',
    RecipientUserId: 'recipientUserId',
    RecipientData: 'recipientData',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsEventScalarFieldEnum = typeof NotificationsEventScalarFieldEnum[keyof typeof NotificationsEventScalarFieldEnum];


/**
 * 
 * @export
 * @interface NotificationsUser
 */
export interface NotificationsUser {
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_recipientUserIdToNotificationsUser'?: Array<NotificationsEvent>;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_senderUserIdToNotificationsUser'?: Array<NotificationsEvent>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsUserScalarFieldEnum = typeof NotificationsUserScalarFieldEnum[keyof typeof NotificationsUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface OAuthProvider
 */
export interface OAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RefreshTokensResponse
 */
export interface RefreshTokensResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SendInvitationLinksArgs
 */
export interface SendInvitationLinksArgs {
    /**
     * 
     * @type {string}
     * @memberof SendInvitationLinksArgs
     */
    'emails': string;
}
/**
 * 
 * @export
 * @interface SignInArgs
 */
export interface SignInArgs {
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface SignOutArgs
 */
export interface SignOutArgs {
    /**
     * 
     * @type {string}
     * @memberof SignOutArgs
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SignUpArgs
 */
export interface SignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'confirmPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200Response
 */
export interface TerminusHealthCheckControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200ResponseInfoValue
 */
export interface TerminusHealthCheckControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck503Response
 */
export interface TerminusHealthCheckControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TokensResponse
 */
export interface TokensResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {EngineUser}
     * @memberof TokensResponse
     */
    'user': EngineUser;
}
/**
 * 
 * @export
 * @interface UpdateEngineEmailTemplateDto
 */
export interface UpdateEngineEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'subject'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'subjectLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'textLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'html'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'htmlLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineEmailTemplateDto
     */
    'operationName'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateEngineProjectDto
 */
export interface UpdateEngineProjectDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineProjectDto
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineProjectDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineProjectDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineProjectDto
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEngineProjectDto
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateEngineRefreshSessionDto
 */
export interface UpdateEngineRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'fingerprint'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'userIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'userData'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEngineRefreshSessionDto
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateEngineUserDto
 */
export interface UpdateEngineUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'roles'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'picture'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateEngineUserDto
     */
    'appData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'revokedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'phoneVerifiedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateEngineUserDto
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateEngineUserDto
     */
    'lang'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateNotificationsEventDto
 */
export interface UpdateNotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'operationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateNotificationsEventDto
     */
    'attempt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationsEventDto
     */
    'used'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'error'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'senderData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientGroupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'externalTenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProfileArgs
 */
export interface UpdateProfileArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'picture'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfileArgs
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'confirmPassword'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWebhookDto
 */
export interface UpdateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'endpoint'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof ValidationError
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof ValidationError
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationError
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ValidationErrorEnum = {
    Validation000: 'VALIDATION-000'
} as const;

export type ValidationErrorEnum = typeof ValidationErrorEnum[keyof typeof ValidationErrorEnum];


/**
 * 
 * @export
 * @interface ValidationErrorMetadata
 */
export interface ValidationErrorMetadata {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadata
     */
    'property': string;
    /**
     * 
     * @type {Array<ValidationErrorMetadataConstraint>}
     * @memberof ValidationErrorMetadata
     */
    'constraints': Array<ValidationErrorMetadataConstraint>;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationErrorMetadata
     */
    'children'?: Array<ValidationErrorMetadata>;
}
/**
 * 
 * @export
 * @interface ValidationErrorMetadataConstraint
 */
export interface ValidationErrorMetadataConstraint {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof Webhook
     */
    'headers': object | null;
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'requestTimeout': number | null;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'workUntilDate': string | null;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_createdByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_updatedByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof Webhook
     */
    'WebhookLog'?: Array<WebhookLog>;
}
/**
 * 
 * @export
 * @interface WebhookEntities
 */
export interface WebhookEntities {
    /**
     * 
     * @type {WebhookScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'Webhook': WebhookScalarFieldEnum;
    /**
     * 
     * @type {WebhookLogScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookLog': WebhookLogScalarFieldEnum;
    /**
     * 
     * @type {WebhookUserScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookUser': WebhookUserScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface WebhookError
 */
export interface WebhookError {
    /**
     * Webhook error (WEBHOOK-000), Tenant ID not set (WEBHOOK-003), User ID not set (WEBHOOK-002), Forbidden (WEBHOOK-001), User not found (WEBHOOK-004), Event not found (WEBHOOK-005)
     * @type {string}
     * @memberof WebhookError
     */
    'message': string;
    /**
     * 
     * @type {WebhookErrorEnum}
     * @memberof WebhookError
     */
    'code': WebhookErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof WebhookError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookErrorEnum = {
    Webhook000: 'WEBHOOK-000',
    Webhook001: 'WEBHOOK-001',
    Webhook002: 'WEBHOOK-002',
    Webhook003: 'WEBHOOK-003',
    Webhook004: 'WEBHOOK-004',
    Webhook005: 'WEBHOOK-005'
} as const;

export type WebhookErrorEnum = typeof WebhookErrorEnum[keyof typeof WebhookErrorEnum];


/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookEvent
     */
    'example': object;
}
/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookLog
     */
    'webhookStatus': WebhookStatus;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'webhookId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'updatedAt': string;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookLog
     */
    'Webhook'?: Webhook;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookLogScalarFieldEnum = {
    Id: 'id',
    Request: 'request',
    ResponseStatus: 'responseStatus',
    Response: 'response',
    WebhookStatus: 'webhookStatus',
    WebhookId: 'webhookId',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookLogScalarFieldEnum = typeof WebhookLogScalarFieldEnum[keyof typeof WebhookLogScalarFieldEnum];


/**
 * 
 * @export
 * @interface WebhookLogsControllerFindManyLogs400Response
 */
export interface WebhookLogsControllerFindManyLogs400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookRole = {
    Admin: 'Admin',
    User: 'User'
} as const;

export type WebhookRole = typeof WebhookRole[keyof typeof WebhookRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookScalarFieldEnum = {
    Id: 'id',
    EventName: 'eventName',
    Endpoint: 'endpoint',
    Enabled: 'enabled',
    Headers: 'headers',
    RequestTimeout: 'requestTimeout',
    ExternalTenantId: 'externalTenantId',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    WorkUntilDate: 'workUntilDate'
} as const;

export type WebhookScalarFieldEnum = typeof WebhookScalarFieldEnum[keyof typeof WebhookScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookStatus = {
    Pending: 'Pending',
    Process: 'Process',
    Success: 'Success',
    Error: 'Error',
    Timeout: 'Timeout'
} as const;

export type WebhookStatus = typeof WebhookStatus[keyof typeof WebhookStatus];


/**
 * 
 * @export
 * @interface WebhookTestRequestResponse
 */
export interface WebhookTestRequestResponse {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookTestRequestResponse
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookTestRequestResponse
     */
    'webhookStatus': WebhookStatus;
}


/**
 * 
 * @export
 * @interface WebhookUser
 */
export interface WebhookUser {
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {WebhookRole}
     * @memberof WebhookUser
     */
    'userRole': WebhookRole;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_createdByToWebhookUser'?: Array<Webhook>;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_updatedByToWebhookUser'?: Array<Webhook>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    UserRole: 'userRole',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookUserScalarFieldEnum = typeof WebhookUserScalarFieldEnum[keyof typeof WebhookUserScalarFieldEnum];



/**
 * EngineApi - axios parameter creator
 * @export
 */
export const EngineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerCompleteForgotPassword: async (completeForgotPasswordArgs: CompleteForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeForgotPasswordArgs' is not null or undefined
            assertParamExists('engineControllerCompleteForgotPassword', 'completeForgotPasswordArgs', completeForgotPasswordArgs)
            const localVarPath = `/api/engine/complete-forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeForgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerCompleteSignUp: async (completeSignUpArgs: CompleteSignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSignUpArgs' is not null or undefined
            assertParamExists('engineControllerCompleteSignUp', 'completeSignUpArgs', completeSignUpArgs)
            const localVarPath = `/api/engine/complete-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSignUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerForgotPassword: async (forgotPasswordArgs: ForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordArgs' is not null or undefined
            assertParamExists('engineControllerForgotPassword', 'forgotPasswordArgs', forgotPasswordArgs)
            const localVarPath = `/api/engine/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerRefreshTokens: async (refreshTokensResponse: RefreshTokensResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokensResponse' is not null or undefined
            assertParamExists('engineControllerRefreshTokens', 'refreshTokensResponse', refreshTokensResponse)
            const localVarPath = `/api/engine/refresh-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokensResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignIn: async (signInArgs: SignInArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInArgs' is not null or undefined
            assertParamExists('engineControllerSignIn', 'signInArgs', signInArgs)
            const localVarPath = `/api/engine/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignOut: async (signOutArgs: SignOutArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signOutArgs' is not null or undefined
            assertParamExists('engineControllerSignOut', 'signOutArgs', signOutArgs)
            const localVarPath = `/api/engine/sign-out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOutArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignUp: async (signUpArgs: SignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpArgs' is not null or undefined
            assertParamExists('engineControllerSignUp', 'signUpArgs', signUpArgs)
            const localVarPath = `/api/engine/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerUpdateProfile: async (updateProfileArgs: UpdateProfileArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileArgs' is not null or undefined
            assertParamExists('engineControllerUpdateProfile', 'updateProfileArgs', updateProfileArgs)
            const localVarPath = `/api/engine/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/email-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineEmailTemplatesControllerFindOne', 'id', id)
            const localVarPath = `/api/engine/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineEmailTemplateDto} updateEngineEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerUpdateOne: async (id: string, updateEngineEmailTemplateDto: UpdateEngineEmailTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineEmailTemplatesControllerUpdateOne', 'id', id)
            // verify required parameter 'updateEngineEmailTemplateDto' is not null or undefined
            assertParamExists('engineEmailTemplatesControllerUpdateOne', 'updateEngineEmailTemplateDto', updateEngineEmailTemplateDto)
            const localVarPath = `/api/engine/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEngineEmailTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineGoogleOAuthControllerGoogleAuth: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('engineGoogleOAuthControllerGoogleAuth', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('engineGoogleOAuthControllerGoogleAuth', 'clientId', clientId)
            const localVarPath = `/api/engine/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineGoogleOAuthControllerGoogleAuthRedirect: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('engineGoogleOAuthControllerGoogleAuthRedirect', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('engineGoogleOAuthControllerGoogleAuthRedirect', 'clientId', clientId)
            const localVarPath = `/api/engine/oauth/google/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineOAuthControllerOauthProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/oauth/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EngineOAuthVerificationArgs} engineOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineOAuthControllerOauthVerification: async (engineOAuthVerificationArgs: EngineOAuthVerificationArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'engineOAuthVerificationArgs' is not null or undefined
            assertParamExists('engineOAuthControllerOauthVerification', 'engineOAuthVerificationArgs', engineOAuthVerificationArgs)
            const localVarPath = `/api/engine/oauth/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(engineOAuthVerificationArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateEngineProjectDto} createEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerCreateOne: async (createEngineProjectDto: CreateEngineProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEngineProjectDto' is not null or undefined
            assertParamExists('engineProjectsControllerCreateOne', 'createEngineProjectDto', createEngineProjectDto)
            const localVarPath = `/api/engine/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEngineProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineProjectsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/engine/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineProjectsControllerFindOne', 'id', id)
            const localVarPath = `/api/engine/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineProjectDto} updateEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerUpdateOne: async (id: string, updateEngineProjectDto: UpdateEngineProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineProjectsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateEngineProjectDto' is not null or undefined
            assertParamExists('engineProjectsControllerUpdateOne', 'updateEngineProjectDto', updateEngineProjectDto)
            const localVarPath = `/api/engine/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEngineProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enginePublicProjectsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/public-projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerFindMany: async (userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('engineRefreshSessionsControllerFindMany', 'userId', userId)
            const localVarPath = `/api/engine/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineRefreshSessionsControllerFindOne', 'id', id)
            const localVarPath = `/api/engine/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineRefreshSessionDto} updateEngineRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerUpdateOne: async (id: string, updateEngineRefreshSessionDto: UpdateEngineRefreshSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineRefreshSessionsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateEngineRefreshSessionDto' is not null or undefined
            assertParamExists('engineRefreshSessionsControllerUpdateOne', 'updateEngineRefreshSessionDto', updateEngineRefreshSessionDto)
            const localVarPath = `/api/engine/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEngineRefreshSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRolesControllerFindMany: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, projectId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/engine/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineUsersControllerFindOne', 'id', id)
            const localVarPath = `/api/engine/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerSendInvitationLinks: async (sendInvitationLinksArgs: SendInvitationLinksArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendInvitationLinksArgs' is not null or undefined
            assertParamExists('engineUsersControllerSendInvitationLinks', 'sendInvitationLinksArgs', sendInvitationLinksArgs)
            const localVarPath = `/api/engine/users/send-invitation-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendInvitationLinksArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineUserDto} updateEngineUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerUpdateOne: async (id: string, updateEngineUserDto: UpdateEngineUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('engineUsersControllerUpdateOne', 'id', id)
            // verify required parameter 'updateEngineUserDto' is not null or undefined
            assertParamExists('engineUsersControllerUpdateOne', 'updateEngineUserDto', updateEngineUserDto)
            const localVarPath = `/api/engine/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEngineUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EngineApi - functional programming interface
 * @export
 */
export const EngineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EngineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerCompleteForgotPassword(completeForgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerCompleteForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerCompleteSignUp(completeSignUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerCompleteSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerForgotPassword(forgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerRefreshTokens(refreshTokensResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerSignIn(signInArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerSignOut(signOutArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerSignOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerSignUp(signUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineControllerUpdateProfile(updateProfileArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEngineEmailTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineEmailTemplatesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineEmailTemplatesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineEmailTemplatesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineEmailTemplateDto} updateEngineEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineEmailTemplatesControllerUpdateOne(id: string, updateEngineEmailTemplateDto: UpdateEngineEmailTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineEmailTemplatesControllerUpdateOne(id, updateEngineEmailTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineEmailTemplatesControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineGoogleOAuthControllerGoogleAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineGoogleOAuthControllerGoogleAuthRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuthProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineOAuthControllerOauthProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineOAuthControllerOauthProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EngineOAuthVerificationArgs} engineOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineOAuthControllerOauthVerification(engineOAuthVerificationArgs: EngineOAuthVerificationArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineOAuthControllerOauthVerification(engineOAuthVerificationArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineOAuthControllerOauthVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateEngineProjectDto} createEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineProjectsControllerCreateOne(createEngineProjectDto: CreateEngineProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineProjectsControllerCreateOne(createEngineProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineProjectsControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineProjectsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineProjectsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineProjectsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEngineProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineProjectsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineProjectsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineProjectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineProjectsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineProjectsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineProjectDto} updateEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineProjectsControllerUpdateOne(id: string, updateEngineProjectDto: UpdateEngineProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineProjectsControllerUpdateOne(id, updateEngineProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineProjectsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enginePublicProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEnginePublicProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enginePublicProjectsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.enginePublicProjectsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEngineRefreshSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineRefreshSessionsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineRefreshSessionsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineRefreshSessionsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineRefreshSessionDto} updateEngineRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineRefreshSessionsControllerUpdateOne(id: string, updateEngineRefreshSessionDto: UpdateEngineRefreshSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineRefreshSessionsControllerUpdateOne(id, updateEngineRefreshSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineRefreshSessionsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineRolesControllerFindMany(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEngineRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineRolesControllerFindMany(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineRolesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, projectId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyEngineUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineUsersControllerFindMany(curPage, perPage, searchText, sort, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineUsersControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineUsersControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineUsersControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineUsersControllerSendInvitationLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineUserDto} updateEngineUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async engineUsersControllerUpdateOne(id: string, updateEngineUserDto: UpdateEngineUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.engineUsersControllerUpdateOne(id, updateEngineUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EngineApi.engineUsersControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EngineApi - factory interface
 * @export
 */
export const EngineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EngineApiFp(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.engineControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<EngineUserDto> {
            return localVarFp.engineControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineControllerSignIn(signInArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.engineControllerSignOut(signOutArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineControllerSignUp(signUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): AxiosPromise<EngineUserDto> {
            return localVarFp.engineControllerUpdateProfile(updateProfileArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyEngineEmailTemplateResponse> {
            return localVarFp.engineEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EngineEmailTemplateDto> {
            return localVarFp.engineEmailTemplatesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineEmailTemplateDto} updateEngineEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineEmailTemplatesControllerUpdateOne(id: string, updateEngineEmailTemplateDto: UpdateEngineEmailTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<EngineEmailTemplateDto> {
            return localVarFp.engineEmailTemplatesControllerUpdateOne(id, updateEngineEmailTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.engineGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): AxiosPromise<Array<OAuthProvider>> {
            return localVarFp.engineOAuthControllerOauthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EngineOAuthVerificationArgs} engineOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineOAuthControllerOauthVerification(engineOAuthVerificationArgs: EngineOAuthVerificationArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.engineOAuthControllerOauthVerification(engineOAuthVerificationArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateEngineProjectDto} createEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerCreateOne(createEngineProjectDto: CreateEngineProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<EngineProjectDto> {
            return localVarFp.engineProjectsControllerCreateOne(createEngineProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.engineProjectsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyEngineProjectResponse> {
            return localVarFp.engineProjectsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EngineProjectDto> {
            return localVarFp.engineProjectsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineProjectDto} updateEngineProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineProjectsControllerUpdateOne(id: string, updateEngineProjectDto: UpdateEngineProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<EngineProjectDto> {
            return localVarFp.engineProjectsControllerUpdateOne(id, updateEngineProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enginePublicProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyEnginePublicProjectResponse> {
            return localVarFp.enginePublicProjectsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyEngineRefreshSessionResponse> {
            return localVarFp.engineRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EngineRefreshSessionDto> {
            return localVarFp.engineRefreshSessionsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineRefreshSessionDto} updateEngineRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRefreshSessionsControllerUpdateOne(id: string, updateEngineRefreshSessionDto: UpdateEngineRefreshSessionDto, options?: RawAxiosRequestConfig): AxiosPromise<EngineRefreshSessionDto> {
            return localVarFp.engineRefreshSessionsControllerUpdateOne(id, updateEngineRefreshSessionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineRolesControllerFindMany(options?: RawAxiosRequestConfig): AxiosPromise<FindManyEngineRoleResponse> {
            return localVarFp.engineRolesControllerFindMany(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, projectId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyEngineUserResponse> {
            return localVarFp.engineUsersControllerFindMany(curPage, perPage, searchText, sort, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EngineUserDto> {
            return localVarFp.engineUsersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateEngineUserDto} updateEngineUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        engineUsersControllerUpdateOne(id: string, updateEngineUserDto: UpdateEngineUserDto, options?: RawAxiosRequestConfig): AxiosPromise<EngineUserDto> {
            return localVarFp.engineUsersControllerUpdateOne(id, updateEngineUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EngineApi - object-oriented interface
 * @export
 * @class EngineApi
 * @extends {BaseAPI}
 */
export class EngineApi extends BaseAPI {
    /**
     * 
     * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompleteSignUpArgs} completeSignUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordArgs} forgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerProfile(options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokensResponse} refreshTokensResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInArgs} signInArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerSignIn(signInArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignOutArgs} signOutArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerSignOut(signOutArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpArgs} signUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerSignUp(signUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileArgs} updateProfileArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineControllerUpdateProfile(updateProfileArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineEmailTemplatesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateEngineEmailTemplateDto} updateEngineEmailTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineEmailTemplatesControllerUpdateOne(id: string, updateEngineEmailTemplateDto: UpdateEngineEmailTemplateDto, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineEmailTemplatesControllerUpdateOne(id, updateEngineEmailTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineOAuthControllerOauthProviders(options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineOAuthControllerOauthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EngineOAuthVerificationArgs} engineOAuthVerificationArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineOAuthControllerOauthVerification(engineOAuthVerificationArgs: EngineOAuthVerificationArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineOAuthControllerOauthVerification(engineOAuthVerificationArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateEngineProjectDto} createEngineProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineProjectsControllerCreateOne(createEngineProjectDto: CreateEngineProjectDto, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineProjectsControllerCreateOne(createEngineProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineProjectsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineProjectsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineProjectsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineProjectsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineProjectsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateEngineProjectDto} updateEngineProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineProjectsControllerUpdateOne(id: string, updateEngineProjectDto: UpdateEngineProjectDto, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineProjectsControllerUpdateOne(id, updateEngineProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public enginePublicProjectsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).enginePublicProjectsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineRefreshSessionsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateEngineRefreshSessionDto} updateEngineRefreshSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineRefreshSessionsControllerUpdateOne(id: string, updateEngineRefreshSessionDto: UpdateEngineRefreshSessionDto, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineRefreshSessionsControllerUpdateOne(id, updateEngineRefreshSessionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineRolesControllerFindMany(options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineRolesControllerFindMany(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [projectId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, projectId?: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineUsersControllerFindMany(curPage, perPage, searchText, sort, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineUsersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateEngineUserDto} updateEngineUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public engineUsersControllerUpdateOne(id: string, updateEngineUserDto: UpdateEngineUserDto, options?: RawAxiosRequestConfig) {
        return EngineApiFp(this.configuration).engineUsersControllerUpdateOne(id, updateEngineUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile: async (downloadUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadUrl' is not null or undefined
            assertParamExists('filesControllerDeleteFile', 'downloadUrl', downloadUrl)
            const localVarPath = `/api/files/delete-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (downloadUrl !== undefined) {
                localVarQueryParameter['downloadUrl'] = downloadUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl: async (ext: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ext' is not null or undefined
            assertParamExists('filesControllerGetPresignedUrl', 'ext', ext)
            const localVarPath = `/api/files/get-presigned-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ext !== undefined) {
                localVarQueryParameter['ext'] = ext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerDeleteFile(downloadUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerDeleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesPresignedUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerGetPresignedUrl(ext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerGetPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.filesControllerDeleteFile(downloadUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): AxiosPromise<FilesPresignedUrls> {
            return localVarFp.filesControllerGetPresignedUrl(ext, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {string} downloadUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerDeleteFile(downloadUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ext 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerGetPresignedUrl(ext, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerFindOne', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne: async (id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateNotificationsEventDto' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'updateNotificationsEventDto', updateNotificationsEventDto)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationsEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyNotificationResponse> {
            return localVarFp.notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerminusHealthCheckApi - axios parameter creator
 * @export
 */
export const TerminusHealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminusHealthCheckApi - functional programming interface
 * @export
 */
export const TerminusHealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminusHealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminusHealthCheckControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminusHealthCheckControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminusHealthCheckApi.terminusHealthCheckControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerminusHealthCheckApi - factory interface
 * @export
 */
export const TerminusHealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminusHealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<TerminusHealthCheckControllerCheck200Response> {
            return localVarFp.terminusHealthCheckControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminusHealthCheckApi - object-oriented interface
 * @export
 * @class TerminusHealthCheckApi
 * @extends {BaseAPI}
 */
export class TerminusHealthCheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminusHealthCheckApi
     */
    public terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig) {
        return TerminusHealthCheckApiFp(this.configuration).terminusHealthCheckControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeApi - axios parameter creator
 * @export
 */
export const TimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeApi - functional programming interface
 * @export
 */
export const TimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeControllerTime(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeControllerTime(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeApi.timeControllerTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeApi - factory interface
 * @export
 */
export const TimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.timeControllerTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeApi - object-oriented interface
 * @export
 * @class TimeApi
 * @extends {BaseAPI}
 */
export class TimeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeControllerTime(options?: RawAxiosRequestConfig) {
        return TimeApiFp(this.configuration).timeControllerTime(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerCreateOne', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerTestRequest', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook/test-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne: async (id: string, updateWebhookDto: UpdateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'id', id)
            // verify required parameter 'updateWebhookDto' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'updateWebhookDto', updateWebhookDto)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs: async (webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookLogsControllerFindManyLogs', 'webhookId', webhookId)
            const localVarPath = `/api/webhook/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (webhookId !== undefined) {
                localVarQueryParameter['webhookId'] = webhookId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateOne(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookTestRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerTestRequest(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerTestRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateOne(id, updateWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindManyLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerCreateOne(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookEvent>> {
            return localVarFp.webhookControllerEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookResponse> {
            return localVarFp.webhookControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<WebhookUser> {
            return localVarFp.webhookControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestRequestResponse> {
            return localVarFp.webhookControllerTestRequest(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookLogsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookLogResponse> {
            return localVarFp.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookLog> {
            return localVarFp.webhookLogsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateOne(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerEvents(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerProfile(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerTestRequest(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWebhookDto} updateWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



